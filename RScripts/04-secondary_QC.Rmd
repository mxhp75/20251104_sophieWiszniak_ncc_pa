---
title: "04-secondary_QC"
author: "Melanie Smith"
date: "2026-01-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Clean-up environment

```{r}
rm(list = ls(all.names = TRUE)) # will clear all objects including hidden objects
gc() # free up memory and report the memory usage
options(max.print = .Machine$integer.max,
        scipen = 999,
        stringsAsFactors = FALSE,
        dplyr.summarise.inform = FALSE) # Print everything without truncation, avoid scientific notation, keep strings as characters, silence dplyr’s “grouped output” informational messages
set.seed(42) # set seed for reproducibility
```

# Load Libraries

```{r}
# Core tidyverse
library(tidyverse)
library(tibble)
library(dplyr)
library(tidyr)

# Single Cell
library(Seurat) # Seurat (relies on dplyr/tidyr, so load after tidyverse)

library(SingleCellExperiment)
library(biomaRt)
library(scuttle)

# additional plotting functions
library(patchwork)
library(pheatmap)
library(RColorBrewer)
```

# User defined functions

```{r}
# quick function (following from Nick's) to plot the QC metrics
my_plot_function <- function(object, grouping_variable, variables_to_plot) {
  
  group_var_sym <- sym(grouping_variable)
  
  object[[]] %>%
    as_tibble(rownames = "barcode") %>%
    dplyr::select(barcode, !!group_var_sym, all_of(variables_to_plot)) %>%
    pivot_longer(
      cols = -c(barcode, !!group_var_sym),
      names_to = "metric",
      values_to = "values"
    ) %>%
    ggplot(aes(x = !!group_var_sym, y = values)) +
    
    # Right half: density + median line
    ggdist::stat_halfeye(
      side = "right",
      fill = "dodgerblue",
      alpha = 0.5,
      .width = 0.5,           # median line
      justification = -0.2,
      scale = 0.9,
      linewidth = 0.4,
      color = "black"
    ) +
    
    # Left half: dots
    ggdist::stat_dots(
      side = "left",
      alpha = 0.3,
      justification = 1.25,
      quantiles = NULL,       # prevents binwidth error
      dotsize = 0.7
    ) +

    facet_wrap(~ metric, scales = "free") +
    theme_bw() +
    theme(
      panel.grid.major.x = element_blank(),
      axis.text.x = element_text(angle = 90, hjust = 0.5)
    )
}
```

# Set project directories and file paths

```{r}
project_name <- "20251104_sophieWiszniak_ncc_pa"

base_repo_dir <- "/home/melanie-smith/workDir/sophieWiszniak"
project_repo_dir <- file.path(base_repo_dir, project_name)
data_base_dir <- file.path(project_repo_dir, "rawData")
out_dir <- file.path(project_repo_dir, "outDir")

new_out_dir <- file.path(out_dir, "05-secondary_QC")

if (!dir.exists(new_out_dir)) {
  dir.create(new_out_dir, recursive = TRUE)
}

```

# Load required objects
- This object has been filtered for doublets and >10% MT genes

```{r}
# read in the latest seurat object. This object has had "any" detected doublet removed, cells with >10% Mt expression removed, cell-type annotations added
re_embed_filtered <- readRDS(file = file.path(out_dir, "04-filtering", "re_embed_filtered.mt_qc.nFeature_top_qc.sex_doublets.annotations.rds"))

# Ensure sophie's annotation is the default identity from here
re_embed_filtered <- SetIdent(re_embed_filtered, value = "sophie_celltype_clean")
```

# Identify GFP reporter gene

```{r}
# Let's find that GFP reporter gene by gene name
grep("GFP", 
     rownames(re_embed_filtered),
     ignore.case = TRUE,
     value = TRUE)

# [1] "Gfpt1"   "Gfpt2"   "pEGFP-1"
# the GFP reporter is annotated as pEGFP-1
```

## UMAP - Original identity

```{r}
DimPlot(re_embed_filtered,
        reduction = "umap",
        group.by = "orig.ident",
        ) +
  labs(
    title = "E11–E12 mouse heart",
    subtitle = "Mib1 KO vs control",
    caption = "Filtered: <10% MT, nFeatures >0.5%, singlets only"
  )

DimPlot(re_embed_filtered,
        group.by = "orig.ident",
        pt.size = 0.8,
        order = c("e11_control", "e11_ko")) +
  # Manually set the colours — E12 samples become light gray, E11 get strong colours
  scale_color_manual(
    values = c(
      "e11_control" = "#2b8cbe",   # strong blue
      "e11_ko"      = "#e34a33",   # strong red/orange
      "e12_control" = "white",    # almost invisible
      "e12_ko"      = "white"     # almost invisible
    )
  ) +
    labs(
    title = "E11.5 mouse heart",
    subtitle = "Mib1 KO vs control (e11 samples highlighted)",
    caption = "Filtered: <10% MT, nFeatures >0.5%, singlets only"
  ) +
  theme(legend.position = "right")
ggsave(filename = file.path(out_dir, "04-filtering/Filter.reembed.umap.e11.png"),
       width = 8, height = 8)

DimPlot(re_embed_filtered,
        group.by = "orig.ident",
        pt.size = 0.8,
        order = c("e12_control", "e12_ko")) +
  # Manually set the colours — E12 samples become light gray, E11 get strong colours
  scale_color_manual(
    values = c(
      "e12_control" = "#2b8cbe",    # almost invisible
      "e12_ko"      = "#e34a33",     # almost invisible
      "e11_control" = "white",   # strong blue
      "e11_ko"      = "white"   # strong red/orange
    )
  ) +
  labs(
    title = "E12.5 mouse heart",
    subtitle = "Mib1 KO vs control (e12 samples highlighted)",
    caption = "Filtered: <10% MT, nFeatures >0.5%, singlets only"
  ) +
  theme(legend.position = "right")
ggsave(filename = file.path(out_dir, "04-filtering/Filter.reembed.umap.e12.png"),
       width = 8, height = 8)

# plot the umap with cluster numbers and colours
DimPlot(re_embed_filtered,
        reduction = "umap",
        group.by = "seurat_clusters",
        label = TRUE,
        label.size = 4
        ) +
    NoLegend() +   # remove legend if too many clusters
  labs(
    title = "E11–E12 mouse heart",
    subtitle = "Mib1 KO vs control",
    caption = "Filtered: <10% MT, nFeatures >0.5%, singlets only"
  )
ggsave(filename = file.path(out_dir, "04-filtering/Filter.reembed.umap.clusters.png"),
       width = 10, height = 8)

gfp_reporter <- FeaturePlot(
  object = re_embed_filtered,
  features = c("pEGFP-1"),
  ncol = 1,                      # side-by-side panels
  order = TRUE                   # high-expression cells on top
  ) &
  scale_colour_gradientn(
    colours = rev(RColorBrewer::brewer.pal(11, "Spectral")),
    name = "Expression"
  ) &
  plot_annotation(
    title = "GFP Reporter",
    caption = "Filtered: <10% MT, singlets only, nFeatures >0.5%"
  ) &
  theme_bw(base_size = 14) &
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

```

# Automatic thresholding via MAD (median absolute deviations)

```{r}
# Enter the number of deviations required
n_mad_hb <- 5 # number of MADs for hb deviation
n_mad <- 3    # number of MADs for nCount and nFeature deviation

# Upper bound for percent.hb -> remove everything ABOVE this number
percent.hb_upper <- median(re_embed_filtered@meta.data$percent.hb) + 
  (mad(re_embed_filtered@meta.data$percent.hb) * n_mad_hb)

# Lower bound for nCounts
nCounts_lower <- median(log10(re_embed_filtered@meta.data$nCount_RNA)) - 
  (mad(log10(re_embed_filtered@meta.data$nCount_RNA)) * n_mad)

# Lower bound for nFeatures -> remove everything BELOW this number
nFeatures_lower <- median(log10(re_embed_filtered@meta.data$nFeature_RNA)) - 
  (mad(log10(re_embed_filtered@meta.data$nFeature_RNA)) * n_mad)

# Calculate the percentage of counts in the top 20 features
counts <- GetAssayData(re_embed_filtered, layer = "counts")
top20_per_cell <- apply(counts, 2, function(x) {
  if(sum(x) == 0) return(0)
  sum(sort(x, decreasing = TRUE)[1:20])
})

# Add to the seurat object
re_embed_filtered$pct_counts_in_top_20_features <- 100 * top20_per_cell / colSums(counts)

# Clean up large object
rm(counts, top20_per_cell)
gc()

# Upper bound for percentage top 20 transcripts (lenient 5 mads)
percent_top20_upper <- median(re_embed_filtered@meta.data$pct_counts_in_top_20_features) + 
  (mad(re_embed_filtered@meta.data$pct_counts_in_top_20_features) * 5)

# Calculate the feature count distance
re_embed_filtered$featcount_dist <- {
  abs(resid(lm(log10(nFeature_RNA + 1) ~ log10(nCount_RNA + 1), 
               data = re_embed_filtered@meta.data)))
}

# Upper bound for feature-count distance (lenient 5 mads)
featCount_dist_upper <- median(re_embed_filtered@meta.data$featcount_dist) + 
  (mad(re_embed_filtered@meta.data$featcount_dist) * 5)

```

# Secondary QC plots

```{r}

# plot the umap with QC metrics (colour using the Spectral palette from RColorBrewer)
FeaturePlot(
  re_embed_filtered,
  features = c(
    "nCount_RNA",
    "nFeature_RNA",
    "percent.mt",
    "percent.hb",
    "featcount_dist",
    "pct_counts_in_top_20_features"
    )
  ) &
  scale_colour_gradientn(
    colours = rev(
      RColorBrewer::brewer.pal(
        n = 11, 
        name = "Spectral")
      )
    )
ggsave(filename = file.path(out_dir, "04-filtering/Filter.reembed.umap.clusters.umap.QC.spectral.png"),
       width = 10, height = 8)

# Specify which metrics we want to look at
qc_metrics <- c("nCount_RNA",
                "nFeature_RNA",
                "percent.mt",
                "percent.hb",
                "percent.ribo",
                "featcount_dist",
                "pct_counts_in_top_20_features",
                "percent.most_abundant",
                "complexity")

# make the plots
secondary_qc_plot <- my_plot_function(
  object = re_embed_filtered,
  grouping_variable = "seurat_clusters",
  variables_to_plot = qc_metrics
)

# add threshold lines to the QC plot
hline_lower <- tibble(
  metric = c("nCount_RNA", "nFeature_RNA"),
  threshold = c(10^nCounts_lower, 10^nFeatures_lower)   # thresholds for each
)
hline_upper <- tibble(
  metric = c("percent.hb", "pct_counts_in_top_20_features", "featcount_dist"),
  threshold = c(percent.hb_upper, percent_top20_upper, featCount_dist_upper)   # thresholds for each
)

# add the hlines
secondary_qc_plot +
  geom_hline(data = hline_lower,
             aes(yintercept = threshold),
             colour = "red",
             linewidth = 1,
             linetype = "dashed")+
  geom_hline(data = hline_upper,
             aes(yintercept = threshold),
             colour = "red",
             linewidth = 1,
             linetype = "dashed")

# plot the nCount x nFeature scatter coloured by %hb
re_embed_filtered@meta.data %>%
  ggplot(aes(x = nCount_RNA,
             y = nFeature_RNA,
             colour = percent.hb)) +
  geom_point() +
  scale_colour_gradient(low = "lightcoral",   # light red for low %
                        high = "darkred",     # dark red for high %
                        na.value = "grey80") +  # gray for any missing values
  geom_hline(yintercept = c(2000, 7500),
             colour = "red",
             linewidth = 1,
             linetype = "dotted") +
  geom_vline(xintercept = c(3500, 50000),
             colour = "red",
             linewidth = 1,
             linetype = "dotted") +
  theme_bw() +
  labs(colour = "% Hb",                      # nicer legend label
       x = "nCount_RNA",                     # optional: clean axis labels
       y = "nFeature_RNA") +
  theme(legend.position = "right")           # optional: legend placement
ggsave(filename = file.path(out_dir, "05-secondary_QC/scatter_all_filters.png"),
       width = 8, height = 8)

## log10 scale the percent.hb for better visualisation
re_embed_filtered$log10_percent.hb <- log10(re_embed_filtered$percent.hb + 1)  # +1 avoids log10(0)

my_plot_function(
  object = re_embed_filtered,
  grouping_variable = "seurat_clusters",
  variables_to_plot = "log10_percent.hb") +
  geom_hline(yintercept = log10(20),
             colour = "red",
             linetype = "dashed",
             linewidth = 2)

## log10 scale the nCount and nFeatures for better visualisation
re_embed_filtered$log10_nCount_RNA <- log10(re_embed_filtered$nCount_RNA + 1)

my_plot_function(
  object = re_embed_filtered,
  grouping_variable = "seurat_clusters",
  variables_to_plot = "log10_nCount_RNA") +
  geom_hline(yintercept = nCounts_lower,
             colour = "red",
             linetype = "dashed",
             linewidth = 1.5)

re_embed_filtered$log10_nFeatures_RNA <- log10(re_embed_filtered$nFeature_RNA + 1)
my_plot_function(
  object = re_embed_filtered,
  grouping_variable = "seurat_clusters",
  variables_to_plot = "log10_nFeatures_RNA") +
  geom_hline(yintercept = nFeatures_lower,
             colour = "red",
             linetype = "dashed",
             linewidth = 1.5)

# Log10 plots - aids visualisation
# Specify which metrics we want to look at
qc_metrics_log10 <- c("log10_nCount_RNA",
                      "log10_nFeatures_RNA",
                      "featcount_dist",
                      "pct_counts_in_top_20_features",
                      "percent.most_abundant",
                      "log10complexity")

# make the plots
secondary_qc_plot <- my_plot_function(
  object = re_embed_filtered,
  grouping_variable = "seurat_clusters",
  variables_to_plot = qc_metrics_log10
)

# add threshold lines to the QC plot
hline_lower_log10 <- tibble(
  metric = c("log10_nCount_RNA", "log10_nFeatures_RNA"),
  threshold = c(nCounts_lower, nFeatures_lower)   # thresholds for each
)
hline_upper_log10 <- tibble(
  metric = c("pct_counts_in_top_20_features", "featcount_dist"),
  threshold = c(percent_top20_upper, featCount_dist_upper)   # thresholds for each
)

# add the hlines
secondary_qc_plot +
  geom_hline(data = hline_lower_log10,
             aes(yintercept = threshold),
             colour = "red",
             linewidth = 1,
             linetype = "dashed")+
  geom_hline(data = hline_upper_log10,
             aes(yintercept = threshold),
             colour = "red",
             linewidth = 1,
             linetype = "dashed")
```

## Complexity plots

```{r}
# Complexity plot coloured by % haemoglobin gene expression
ggplot(re_embed_filtered@meta.data,
       aes(x = log10_nCount_RNA,
           y = log10_nFeatures_RNA,
           color = percent.hb)) +
  geom_point(size = 1, alpha = 0.7) +
  scale_color_gradient(low = "grey80", high = "#8B0000",      # DarkRed
                       name = "% Haemoglobin",
                       breaks = scales::pretty_breaks(n = 5)) +
  labs(title = "Library complexity vs library size",
       x = "log₁₀(nCount_RNA + 1)",
       y = "log₁₀(nFeature_RNA + 1)") +
  geom_vline(xintercept = nCounts_lower,
             colour = "red",
             linetype = "dashed",
             linewidth = 1) +
  geom_hline(yintercept = nFeatures_lower,
             colour = "red",
             linetype = "dashed",
             linewidth = 1) +
  theme_bw()

# Complexity plot showing only cells from clusters 5, 8, 12, 18, 20, 21, 24 (seurat_clusters)
re_embed_filtered@meta.data %>%
  filter(seurat_clusters %in% c(5, 8, 12, 18, 20, 21, 24)) %>%
  ggplot(aes(x = log10_nCount_RNA,
             y = log10_nFeatures_RNA,
             color = factor(seurat_clusters))) +
  geom_point(size = 1.5, alpha = 0.9) +
  scale_color_viridis_d(option = "turbo", end = 0.95) +
  geom_vline(xintercept = nCounts_lower,   colour = "red", linetype = "dashed", linewidth = 1.2) +
  geom_hline(yintercept = nFeatures_lower, colour = "red", linetype = "dashed", linewidth = 1.2) +
  labs(title = "E11–E12 mouse heart",
    subtitle = "Clusters of questionable quality",
    caption = "Filtered: <10% MT, singlets only",
       x = "log₁₀(nCount_RNA + 1)",
       y = "log₁₀(nFeature_RNA + 1)",
       color = "Cluster") +
  theme_bw(base_size = 14)

# facet all cell types
re_embed_filtered@meta.data %>%
  arrange(percent.hb) %>%                                   # sort so high Hb on top
  ggplot(aes(x = log10_nCount_RNA,
             y = log10_nFeatures_RNA,
             color = percent.hb)) +                         # ← + goes HERE
  geom_point(size = 1.8, alpha = 0.9) +
  scale_color_gradient(low = "white", high = "#8B0000",
                       name = "% Haemoglobin") +
  geom_vline(xintercept = nCounts_lower,   colour = "red", linetype = "dashed", linewidth = 1.2) +
  geom_hline(yintercept = nFeatures_lower, colour = "red", linetype = "dashed", linewidth = 1.2) +
  facet_wrap(~ sophie_celltype_clean, ncol = 5) +
  labs(title = "Library complexity vs library size — selected clusters",
       x = "log₁₀(nCount_RNA + 1)",
       y = "log₁₀(nFeature_RNA + 1)") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank())

# facet all clusters
re_embed_filtered@meta.data %>%
  # filter(seurat_clusters %in% c(2, 18, 28, 29)) %>%
  arrange(percent.hb) %>%                                   # sort so high Hb on top
  ggplot(aes(x = log10_nCount_RNA,
             y = log10_nFeatures_RNA,
             color = percent.hb)) +                         # ← + goes HERE
  geom_point(size = 1.8, alpha = 0.9) +
  scale_color_gradient(low = "white", high = "#8B0000",
                       name = "% Haemoglobin") +
  geom_vline(xintercept = nCounts_lower,   colour = "red", linetype = "dashed", linewidth = 1.2) +
  geom_hline(yintercept = nFeatures_lower, colour = "red", linetype = "dashed", linewidth = 1.2) +
  facet_wrap(~ seurat_clusters, ncol = 5) +
  labs(title = "Library complexity vs library size — selected clusters",
       x = "log₁₀(nCount_RNA + 1)",
       y = "log₁₀(nFeature_RNA + 1)") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank())

# Plot the percentage of expression from the top 20 genes
VlnPlot(re_embed_filtered,
        features = "pct_counts_in_top_20_features",
        group.by = "seurat_clusters") +
  geom_hline(yintercept = percent_top20_upper, 
             colour = "red",
             linetype = "dashed",
             linewidth = 1.2) +
  theme_bw()

# Plot the distance from the expected relationship between nCounts and nFeatures
# Now plot it — you’ll love it
VlnPlot(re_embed_filtered,
        features = "featcount_dist",
        group.by = "seurat_clusters") +
  geom_hline(yintercept = featCount_dist_upper,
             colour = "red",
             linetype = "dashed") + 
  theme_bw()
  
```

## Define final thresholds (all cells combined)

```{r}
qc_thresholds <- list(
  nCount_RNA_lower      = 10^nCounts_lower,
  nFeature_RNA_lower    = 10^nFeatures_lower,
  percent.hb_upper      = percent.hb_upper,
  pct_top20_upper       = percent_top20_upper,
  featcount_dist_upper  = featCount_dist_upper
)

# Print thresholds for documentation
cat("=== QC Thresholds Applied ===\n")
cat("nCount_RNA_lower:     ", round(qc_thresholds$nCount_RNA_lower, 2), "\n")
cat("nFeature_RNA_lower:   ", round(qc_thresholds$nFeature_RNA_lower, 2), "\n")
cat("percent.hb_upper:     ", round(qc_thresholds$percent.hb_upper, 2), "%\n")
cat("pct_top20_upper:      ", round(qc_thresholds$pct_top20_upper, 2), "%\n")
cat("featcount_dist_upper: ", round(qc_thresholds$featcount_dist_upper, 4), "\n\n")
```

# Remove low quality clusters (5, 8, 12, 18, 20, 21, 24) and re-embed

```{r}
# Check starting number of cells
cat("Starting number of cells:", ncol(re_embed_filtered), "\n")
cat("Cells in cluster 5:", sum(re_embed_filtered$seurat_clusters == 5), "\n")
cat("Cells in cluster 8:", sum(re_embed_filtered$seurat_clusters == 8), "\n")
cat("Cells in cluster 12:", sum(re_embed_filtered$seurat_clusters == 12), "\n")
cat("Cells in cluster 18:", sum(re_embed_filtered$seurat_clusters == 18), "\n")
cat("Cells in cluster 20:", sum(re_embed_filtered$seurat_clusters == 20), "\n")
cat("Cells in cluster 21:", sum(re_embed_filtered$seurat_clusters == 21), "\n")
cat("Cells in cluster 24:", sum(re_embed_filtered$seurat_clusters == 24), "\n")
cat("Total low-quality cells to remove:", sum(re_embed_filtered$seurat_clusters %in% c(5, 8, 12, 18, 20, 21, 24)), "\n\n")

# save the existing seurat cluster assignments in the metadata
re_embed_filtered$original_clusters_mt_dbl <- re_embed_filtered$seurat_clusters

# Subset to remove low-quality clusters
re_embed_no_low.qual <- subset(re_embed_filtered, 
                          subset = seurat_clusters %in% c(5, 8, 12, 18, 20, 21, 24), 
                          invert = TRUE)

cat("Cells after low-quality removal:", ncol(re_embed_no_low.qual), "\n\n")

```

# Perform secodary QC per cluster and remove remaining low quality cells
## Set MADs

```{r}
# Enter the number of deviations required
n_mad_3 <- 3    # number of MADs for nCount and nFeature deviation
n_mad_5 <- 5    # number of MADs for featcount_dist and pct_counts_in_top_20_features deviation
```

## nFeatures

```{r}
# Compute per-cluster lower threshold and add logical flag
re_embed_no_low.qual@meta.data <- re_embed_no_low.qual@meta.data %>%
  tibble::rownames_to_column("cell_id") %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::mutate(
    # Compute threshold per cluster (on log scale for skewness)
    lower_threshold = median(log10(nFeature_RNA + 1)) - (mad(log10(nFeature_RNA + 1)) * n_mad_3),
    # Flag cells below the threshold (TRUE = low quality)
    nFeature_filter = log10(nFeature_RNA + 1) < lower_threshold
  ) %>%
  dplyr::ungroup() %>%
  tibble::column_to_rownames("cell_id")

# Count flagged cells per cluster
table(re_embed_no_low.qual@meta.data$seurat_clusters, re_embed_no_low.qual@meta.data$nFeature_filter)

# Per-cluster thresholds
threshold_nFeature <- re_embed_no_low.qual@meta.data %>%
  group_by(seurat_clusters) %>%
  summarize(unique_threshold_nFeature = unique(lower_threshold)) %>%
  dplyr::mutate(threshold_nFeature = 10^unique_threshold_nFeature)

# Step 2: Create VlnPlot (on linear scale, which is most common for nFeature)
p <- VlnPlot(re_embed_no_low.qual,
             features = "nFeature_RNA",
             group.by = "seurat_clusters",
             pt.size = 0.5,
             cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  labs(title = "Per Cluster Lower nFeature QC Thresholds",
       y = "nFeature_RNA",
       subtitle = paste("Threshold = median(log10(nFeature)) -", n_mad_3, "× MAD"),
       caption = "Filtered: <10% MT, singlets only, no low quality (5, 8, 12, 18, 20, 21, 24) old clusters") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# manually set the y-limit
p <- p + 
  ylim(0, max(re_embed_no_low.qual@meta.data$nFeature_RNA, na.rm = TRUE) * 1.05)

# Short cluster level red dashed segment and threshold value centered on each violin
p + geom_segment(
  data = threshold_nFeature,
  aes(
    x = as.numeric(seurat_clusters) - 0.35,     # start a bit left of center
    xend = as.numeric(seurat_clusters) + 0.35,  # end a bit right of center
    y = threshold_nFeature,
    yend = threshold_nFeature
  ),
  color = "red",
  linetype = "dashed",
  size = 0.9,
  inherit.aes = FALSE
) +
  # White box label with slight padding and border
  geom_label(
    data = threshold_nFeature,
    aes(
      x = as.numeric(seurat_clusters),
      y = threshold_nFeature * 1.12,
      label = round(threshold_nFeature, 0)
    ),
    color = "black",                # text color
    fill = "white",                 # background color (white box)
    label.size = 0.35,              # thickness of the border (set to 0 for no border)
    size = 3.2,                     # text size
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  NoLegend()

# clean up object
rm(threshold_nFeature)
gc()
```

## nCounts

```{r}
# Compute per-cluster lower threshold and add logical flag
re_embed_no_low.qual@meta.data <- re_embed_no_low.qual@meta.data %>%
  tibble::rownames_to_column("cell_id") %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::mutate(
    # Compute threshold per cluster (on log scale for skewness)
    lower_threshold = median(log10(nCount_RNA + 1)) - (mad(log10(nCount_RNA + 1)) * n_mad_3),
    # Flag cells below the threshold (TRUE = low quality)
    nCounts_filter = log10(nCount_RNA + 1) < lower_threshold
  ) %>%
  dplyr::ungroup() %>%
  tibble::column_to_rownames("cell_id")

# Count flagged cells per cluster
table(re_embed_no_low.qual@meta.data$seurat_clusters, re_embed_no_low.qual@meta.data$nCounts_filter)

# Per-cluster thresholds
threshold_nCounts <- re_embed_no_low.qual@meta.data %>%
  group_by(seurat_clusters) %>%
  summarize(unique_threshold_nCounts = unique(lower_threshold)) %>%
  dplyr::mutate(threshold_nCounts = 10^unique_threshold_nCounts)

# Step 2: Create VlnPlot (on linear scale, which is most common for nFeature)
p <- VlnPlot(re_embed_no_low.qual,
             features = "nCount_RNA",
             group.by = "seurat_clusters",
             pt.size = 0.5,
             cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  labs(title = "Per Cluster Lower nCounts QC Thresholds",
       y = "nCount_RNA",
       subtitle = paste("Threshold = median(log10(nCounts)) -", n_mad_3, "× MAD"),
       caption = "Filtered: <10% MT, singlets only, no low quality (5, 8, 12, 18, 20, 21, 24) old clusters") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# manually set the y-limit
p <- p + ylim(0, max(re_embed_no_low.qual@meta.data$nCount_RNA, na.rm = TRUE) * 1.05)

# Short cluster level red dashed segment and threshold value centered on each violin
p + geom_segment(
  data = threshold_nCounts,
  aes(
    x = as.numeric(seurat_clusters) - 0.35,     # start a bit left of center
    xend = as.numeric(seurat_clusters) + 0.35,  # end a bit right of center
    y = threshold_nCounts,
    yend = threshold_nCounts
  ),
  color = "red",
  linetype = "dashed",
  size = 0.9,
  inherit.aes = FALSE
) +
  # White box label with slight padding and border
  geom_label(
    data = threshold_nCounts,
    aes(
      x = as.numeric(seurat_clusters),
      y = threshold_nCounts * 1.12,
      label = round(threshold_nCounts, 0)
    ),
    color = "black",                # text color
    fill = "white",                 # background color (white box)
    label.size = 0.35,              # thickness of the border (set to 0 for no border)
    size = 3.2,                     # text size
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  NoLegend()

# clean up object
rm(threshold_nCounts)
gc()
```

## featcount_dist

```{r}
# Compute per-cluster lower threshold and add logical flag
re_embed_no_low.qual@meta.data <- re_embed_no_low.qual@meta.data %>%
  tibble::rownames_to_column("cell_id") %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::mutate(
    # Compute threshold per cluster (on log10 scale for skewness)
    upper_threshold = median(log10(featcount_dist + 1)) + (mad(log10(featcount_dist + 1)) * n_mad_3),
    # Flag cells above the threshold (TRUE = low quality)
    featcount_dist_filter = log10(featcount_dist + 1) > upper_threshold
  ) %>%
  dplyr::ungroup() %>%
  tibble::column_to_rownames("cell_id")

# Count flagged cells per cluster
table(re_embed_no_low.qual@meta.data$seurat_clusters, re_embed_no_low.qual@meta.data$featcount_dist_filter)

# Per-cluster thresholds
threshold_featcount_dist <- re_embed_no_low.qual@meta.data %>%
  group_by(seurat_clusters) %>%
  summarize(unique_threshold_featcount_dist = unique(upper_threshold)) %>%
  dplyr::mutate(threshold_featcount_dist = 10^unique_threshold_featcount_dist)

# Step 2: Create VlnPlot (on linear scale, which is most common for nFeature)
p <- VlnPlot(re_embed_no_low.qual,
             features = "featcount_dist",
             group.by = "seurat_clusters",
             pt.size = 0.5,
             cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  labs(title = "Per Cluster Lower featcount_dist QC Thresholds",
       y = "featcount_dist",
       subtitle = paste("Threshold = median(log10(featcount_dist)) +", n_mad_3, "× MAD"),
       caption = "Filtered: <10% MT, singlets only, no low quality (5, 8, 12, 18, 20, 21, 24) old clusters") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# manually set the y-limit
p <- p + ylim(0, max(re_embed_no_low.qual@meta.data$featcount_dist, na.rm = TRUE) * 1.5)

# Short cluster level red dashed segment and threshold value centered on each violin
p + geom_segment(
  data = threshold_featcount_dist,
  aes(
    x = as.numeric(seurat_clusters) - 0.35,     # start a bit left of center
    xend = as.numeric(seurat_clusters) + 0.35,  # end a bit right of center
    y = threshold_featcount_dist,
    yend = threshold_featcount_dist
  ),
  color = "red",
  linetype = "dashed",
  size = 0.9,
  inherit.aes = FALSE
) +
  # White box label with slight padding and border
  geom_label(
    data = threshold_featcount_dist,
    aes(
      x = as.numeric(seurat_clusters),
      y = threshold_featcount_dist * 1.05,
      label = round(threshold_featcount_dist, 0)
    ),
    color = "black",                # text color
    fill = "white",                 # background color (white box)
    label.size = 0.35,              # thickness of the border (set to 0 for no border)
    size = 3.2,                     # text size
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  NoLegend()

# clean up object
rm(threshold_featcount_dist)
gc()
```

## pct_counts_in_top_20_features

```{r}
# Compute per-cluster lower threshold and add logical flag
re_embed_no_low.qual@meta.data <- re_embed_no_low.qual@meta.data %>%
  tibble::rownames_to_column("cell_id") %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::mutate(
    # Compute threshold per cluster
    upper_threshold = median(pct_counts_in_top_20_features) + (mad(pct_counts_in_top_20_features) * n_mad_3),
    # Flag cells above the threshold (TRUE = low quality)
    pct_counts_in_top_20_features_filter = pct_counts_in_top_20_features > upper_threshold
  ) %>%
  dplyr::ungroup() %>%
  tibble::column_to_rownames("cell_id")

# Count flagged cells per cluster
table(re_embed_no_low.qual@meta.data$seurat_clusters, re_embed_no_low.qual@meta.data$pct_counts_in_top_20_features_filter)

# Per-cluster thresholds
threshold_pct_counts_in_top_20_features <- re_embed_no_low.qual@meta.data %>%
  group_by(seurat_clusters) %>%
  summarize(unique_threshold_pct_counts_in_top_20_features = unique(upper_threshold)) %>%
  dplyr::mutate(threshold_pct_counts_in_top_20_features = unique_threshold_pct_counts_in_top_20_features)

# Step 2: Create VlnPlot (on linear scale, which is most common for nFeature)
p <- VlnPlot(re_embed_no_low.qual,
             features = "pct_counts_in_top_20_features",
             group.by = "seurat_clusters",
             pt.size = 0.5,
             cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  labs(title = "Per Cluster Lower pct_counts_in_top_20_features QC Thresholds",
       y = "pct_counts_in_top_20_features",
       subtitle = paste("Threshold = median(pct_counts_in_top_20_features) +", n_mad_3, "× MAD"),
       caption = "Filtered: <10% MT, singlets only, no low quality (5, 8, 12, 18, 20, 21, 24) old clusters") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# manually set the y-limit
p <- p + ylim(0, max(re_embed_no_low.qual@meta.data$pct_counts_in_top_20_features, na.rm = TRUE) * 1.3)

# Short cluster level red dashed segment and threshold value centered on each violin
p + geom_segment(
  data = threshold_pct_counts_in_top_20_features,
  aes(
    x = as.numeric(seurat_clusters) - 0.35,     # start a bit left of center
    xend = as.numeric(seurat_clusters) + 0.35,  # end a bit right of center
    y = threshold_pct_counts_in_top_20_features,
    yend = threshold_pct_counts_in_top_20_features
  ),
  color = "red",
  linetype = "dashed",
  size = 0.9,
  inherit.aes = FALSE
) +
  # White box label with slight padding and border
  geom_label(
    data = threshold_pct_counts_in_top_20_features,
    aes(
      x = as.numeric(seurat_clusters),
      y = threshold_pct_counts_in_top_20_features * 1.5,
      label = round(threshold_pct_counts_in_top_20_features, 0)
    ),
    color = "black",                # text color
    fill = "white",                 # background color (white box)
    label.size = 0.35,              # thickness of the border (set to 0 for no border)
    size = 3.2,                     # text size
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  NoLegend()

# clean up object
rm(threshold_pct_counts_in_top_20_features)
gc()
```

# Test QC fails

```{r}
# Step 1: Create combined "any fail" and "fail 2+" columns
re_embed_no_low.qual@meta.data <- re_embed_no_low.qual@meta.data %>%
  mutate(
    any_qc_fail = nFeature_filter |
      nCounts_filter | 
      pct_counts_in_top_20_features_filter | 
      featcount_dist_filter,
    
    # Count how many filters each cell fails
    num_qc_fails = rowSums(across(c(nFeature_filter, 
                                    nCounts_filter, 
                                    pct_counts_in_top_20_features_filter, 
                                    featcount_dist_filter)), na.rm = TRUE),
    
    # NEW: TRUE only if cell fails 2 or more filters
    fail_any_2 = num_qc_fails >= 2
  )

# Step 2: Summary table per cluster
qc_fail_summary <- re_embed_no_low.qual@meta.data %>%
  group_by(seurat_clusters) %>%
  summarise(
    total_cells       = n(),
    n_fail_any        = sum(any_qc_fail, na.rm = TRUE),
    pct_fail_any      = round(100 * n_fail_any / total_cells, 2),
    
    n_fail_nFeature   = sum(nFeature_filter, na.rm = TRUE),
    n_fail_nCounts    = sum(nCounts_filter, na.rm = TRUE),
    n_fail_top20      = sum(pct_counts_in_top_20_features_filter, na.rm = TRUE),
    n_fail_featdist   = sum(featcount_dist_filter, na.rm = TRUE),
    
    # Updated: only cells failing 2 or more filters
    fail_any_2        = sum(fail_any_2, na.rm = TRUE),
    pct_fail_any_2    = round(100 * fail_any_2 / total_cells, 2)
  ) %>%
  ungroup() %>%
  arrange(as.numeric(seurat_clusters))  # sort by cluster number

# Print the summary table
print(qc_fail_summary)

# Optional: Save to CSV
write_csv(qc_fail_summary, 
          file = file.path(out_dir, "05-secondary_QC", "per_cluster_qc_fail_summary.csv"))


```

# Perform secondary filtering

```{r}
# Double-check the numbers before subsetting
# How many cells fail 0, 1, 2, 3, or 4 filters?
table(re_embed_no_low.qual@meta.data$num_qc_fails)

# How many would be kept vs removed?
re_embed_no_low.qual@meta.data %>%
  summarise(
    total_cells = n(),
    keep_cells = sum(fail_any_2 == FALSE, na.rm = TRUE),
    remove_cells = sum(fail_any_2 == TRUE, na.rm = TRUE),
    pct_removed = round(100 * remove_cells / total_cells, 2)
  )

# Subset to keep only cells that fail < 2 filters (i.e. fail_any_2 == FALSE)
re_embed_filtered <- subset(re_embed_no_low.qual,
                            subset = fail_any_2 == FALSE)

# Or equivalently (using the count):
# re_embed_filtered <- subset(re_embed_no_low.qual,
#                             subset = num_qc_fails < 2)

# Quick sanity check after subsetting
cat("Original cells:", ncol(re_embed_no_low.qual), "\n")
cat("Kept cells:", ncol(re_embed_filtered), "\n")
cat("Removed cells:", ncol(re_embed_no_low.qual) - ncol(re_embed_filtered), "\n")

# Create individual VlnPlots for each feature
p1 <- VlnPlot(re_embed_no_low.qual, features = "nFeature_RNA", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

p2 <- VlnPlot(re_embed_no_low.qual, features = "nCount_RNA", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

p3 <- VlnPlot(re_embed_no_low.qual, features = "featcount_dist", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

p4 <- VlnPlot(re_embed_no_low.qual, features = "pct_counts_in_top_20_features", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

# Combine into 2x2 grid with shared title & caption
(p1 | p2) / (p3 | p4) +
  plot_annotation(
    title = "Pre-filter QC Metrics",
    caption = "Filtered: MT, doublets, low qual clusters & cells (old clusters)",
    theme = theme(plot.title = element_text(hjust = 0.5, size = 14))
  ) +
  plot_layout(guides = "collect")

ggsave(filename = file.path(new_out_dir, "Pre-filter-violins.png"))


# Post filtering
# Create individual VlnPlots for each feature
p1 <- VlnPlot(re_embed_filtered, features = "nFeature_RNA", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

p2 <- VlnPlot(re_embed_filtered, features = "nCount_RNA", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

p3 <- VlnPlot(re_embed_filtered, features = "featcount_dist", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

p4 <- VlnPlot(re_embed_filtered, features = "pct_counts_in_top_20_features", 
              group.by = "seurat_clusters",
              pt.size = 0.5,
              alpha = 0.4,
              cols = scales::hue_pal()(length(unique(re_embed_no_low.qual$seurat_clusters)))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = "none")

# Combine into 2x2 grid with shared title & caption
(p1 | p2) / (p3 | p4) +
  plot_annotation(
    title = "Post-filter QC Metrics",
    caption = "Filtered: MT, doublets, low qual clusters & cells (old clusters)",
    theme = theme(plot.title = element_text(hjust = 0.5, size = 14))
  ) +
  plot_layout(guides = "collect")

ggsave(filename = file.path(new_out_dir, "Post-filter-violins.png"))

```

# Re-embed: Normalise, find variable features, scale, PCA, UMAP, cluster

```{r}
n_dims = 30
clustering_resolution = 0.8
# Re-computation of graph-based clustering and UMAP on the cleaned dataset
re_embed_filtered <- FindVariableFeatures(re_embed_filtered,
                                        selection.method = "vst", 
                                        nfeatures = 3000,
                                        verbose = FALSE) %>%
  ScaleData(features = rownames(re_embed_no_low.qual),
            verbose = FALSE) %>%
  RunPCA(verbose = FALSE) %>% # Defaults to features = VariableFeatures()), but better not to specify as these are not yet stored in that object
  FindNeighbors(dims = 1:n_dims,
                verbose = FALSE) %>%
  FindClusters(resolution = clustering_resolution,
               verbose = FALSE) %>%
  RunUMAP(dims = 1:n_dims,
          verbose = FALSE)

# plot the umap with old cluster numbers and colours
DimPlot(re_embed_filtered,
        reduction = "umap",
        group.by = "original_clusters_mt_dbl",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (old clusters)",
    caption = "Filtered: MT, doublets, low qual clusters & cells (old clusters)"
  ) +
  NoLegend()
ggsave(filename = file.path(new_out_dir, "umap.filtered.mt.doublet.nFeature_top.low_quality_clust_cell.old_clusters.png"),
       width = 8, height = 8)

# plot the umap with old cluster numbers and colours
DimPlot(re_embed_filtered,
        reduction = "umap",
        group.by = "seurat_clusters",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (new clusters)",
    caption = "Filtered: MT, doublets, low qual clusters & cells (new clusters)"
  ) +
  NoLegend()
ggsave(filename = file.path(new_out_dir, "umap.filtered.mt.doublet.nFeature_top.low_quality_clust_cell.new_clusters.png"),
       width = 8, height = 8)

# plot the umap with cluster numbers and colours
DimPlot(re_embed_filtered,
        reduction = "umap",
        group.by = "sophie_celltype_clean",
        label = TRUE,
        label.size = 4
        ) +
  labs(
    title = "UMAP - new embedding (Sophie anno)",
    caption = "Filtered: MT, doublets, low qual clusters & cells (Sophie Anno)"
  )
ggsave(filename = file.path(new_out_dir, "umap.filtered.mt.doublet.nFeature_top.low_quality_clust_cell.sophie_anno.png"),
       width = 8, height = 8)

# let's save here and reload in a new session
write_rds(x = re_embed_filtered,
          file = file.path(new_out_dir, "re_embed_filtered_no_multi_fail.rds"))

```

# Visualize the new embedding

```{r}

# Check QC metrics in the new embedding
p3 <- FeaturePlot(re_embed_filtered, 
                  features = c("nCount_RNA", "nFeature_RNA", 
                               "percent.mt", "percent.hb",
                               "featcount_dist", "pct_counts_in_top_20_features"),
                  ncol = 3)  &
  scale_colour_gradientn(
    colours = rev(
      RColorBrewer::brewer.pal(
        n = 11, 
        name = "Spectral")
      )
    )
print(p3)
ggsave(p3, 
       filename = file.path(new_out_dir, "filtered.mt.doublet.nFeature_top.low_quality.QCmetrics.png"),
       width = 12,
       height = 8)

```