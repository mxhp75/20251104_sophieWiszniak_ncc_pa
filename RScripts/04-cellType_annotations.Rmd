---
title: "cellType_annotations"
output: html_document
date: "2025-11-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Clean-up environment

```{r}
rm(list = ls(all.names = TRUE)) # will clear all objects includuing hidden objects
gc() # free up memory and report the memory usage
options(max.print = .Machine$integer.max, scipen = 999, stringsAsFactors = FALSE, dplyr.summarise.inform = FALSE) # Print everything without truncation, avoid scientific notation, keep strings as characters, silence dplyr’s “grouped output” informational messages
set.seed(42) # set seed for reprodcibility
```

# Load Libraries

```{r}
# Core tidyverse
library(tidyverse)
library(tibble)
library(dplyr)
library(tidyr)

# Single Cell
# BiocManager::install(c("SingleR", "celldex"))
library(celldex)
library(SingleR)
library(Seurat) # Seurat (relies on dplyr/tidyr, so load after tidyverse)
# BiocManager::install("zellkonverter")
library(zellkonverter)

library(SingleCellExperiment)
library(biomaRt)
library(scuttle)
```

# Set project directories and file paths

```{r}
project_name <- "20251104_sophieWiszniak_ncc_pa"

base_repo_dir <- "/home/melanie-smith/workDir/sophieWiszniak"
project_repo_dir <- file.path(base_repo_dir, project_name)
data_base_dir <- file.path(project_repo_dir, "rawData")
out_dir <- file.path(project_repo_dir, "outDir")
downloads <- file.path(project_repo_dir, "downloads")

# Files for reading in
sophieAnnotation_file <- file.path(project_repo_dir, "cleanData/seurat_clusters.csv")

```

# Load required objects
- This object has been filtered for doublets, 

```{r}
# seurat object
# joined <- read_rds(file = file.path(out_dir, "04-filtering", "filtered.perform_qc.sex_doublets.rds"))
re_embed_filtered <- readRDS(file = file.path(out_dir, "04-filtering", "re_embed_filtered.perform_qc.sex_doublets.rds"))
# Sophie's annotation file
sophieAnnotation <- read_csv(sophieAnnotation_file)

# one to one mapping of original, merged and Joe barcodes
joined_metadata_with_barcodes <- read_csv("outDir/03-merged_initial_QC/joined_metadata_with_barcodes.csv")

```

## Get normalised counts
- note that SingleR will accept raw or normalised counts

```{r}
raw_counts <- LayerData(re_embed_filtered, assay = "RNA", layer = 'counts') #
raw_counts[c('Vim', 'Bcl2', 'Trp53', 'Cd4'),1:5]
norm_counts <- LayerData(re_embed_filtered, assay = "RNA", layer = 'data') #
norm_counts[c('Vim', 'Bcl2', 'Trp53', 'Cd4'),1:5]
```

# 1. Manual Annotation using Sophie's list
- This chunk uses Sophie's manually curated list of cell types

## Add Sophie's cell annotation map to the seurat object

```{r}
# join Sophie's annotations with the barcode mapping object
manual_annotation <- dplyr::left_join(
  joined_metadata_with_barcodes,
  sophieAnnotation,
  by = (c("joe_barcode" = "Barcode")
        )
  ) %>%
  dplyr::mutate(
    seurat_clusters = ifelse(is.na(seurat_clusters), "filtered", seurat_clusters)
    ) %>%
  dplyr::select(., merged_barcodes, sophie_annotation = seurat_clusters) %>%
  tibble::column_to_rownames("merged_barcodes")

# add the manually curated labels to the seurat object
re_embed_filtered <- AddMetaData(
  object = re_embed_filtered,
  metadata = manual_annotation,
  col.name = "sophie_annotation"
)

# set the active identity
re_embed_filtered <- SetIdent(re_embed_filtered,
                   value = "sophie_annotation")
# Visualise them on the UMAP
DimPlot(re_embed_filtered,
        group.by = "sophie_annotation",
        label = TRUE,
        repel = TRUE,
        label.size = 3)

# Nicer colors + filtered in gray
n_clusters <- length(unique(re_embed_filtered$sophie_annotation))
cluster_colours <- c(
  scales::hue_pal()(n_clusters - 1),   # bright colors for real clusters
  "gray70"                             # filtered = muted gray
)
names(cluster_colours) <- levels(re_embed_filtered$sophie_annotation)

DimPlot(re_embed_filtered,
        group.by = "sophie_annotation",
        label = TRUE,
        repel = TRUE,
        cols = cluster_colours,
        pt.size = 0.4) +
  # NoLegend() +   # remove legend if too many clusters
  ggtitle("Sophie's manual cell type annotation transferred via joe_barcode")
```

## Remove the prefix from Sophie's cell types and replot

```{r}
re_embed_filtered$sophie_celltype_clean <- sub("^[0-9]+_", "", re_embed_filtered$sophie_annotation)

# Generate colors for all real cell types
real_types <- setdiff(unique(re_embed_filtered$sophie_celltype_clean), "filtered")
palette <- scales::hue_pal()(length(real_types))
names(palette) <- real_types

# Add gray for filtered
cluster_colours_clean <- c(palette, filtered = "gray70")

DimPlot(re_embed_filtered,
        group.by = "sophie_celltype_clean",
        cols = cluster_colours_clean,
        label = TRUE, repel = TRUE) +
  ggtitle("Sophie's manual annotation (clean cell types)")
```


# 2. Cell annotation with celldex
- This chunk uses the celldex mouse RNAseq dataset

## Get reference dataset

```{r}
ref <- celldex::MouseRNAseqData()
unique(ref$label.main)
unique(ref$label.fine)
```

## Subset the cell types to include only what we expect to see in heart

```{r}
ref_main <- ref[,grepl('Cardiomyocytes|Fibroblasts|Endothelial cells|Macrophages|Monocytes|T cells|B cells|NK cells|Dendritic cells|Granulocytes|Adipocytes|Erythrocytes', ref$label.main)]
unique(ref_main$label.main)

ref_fine <- ref[,grepl('Cardiomyocytes|Fibroblasts|Fibroblasts activated|Fibroblasts senescent|Endothelial cells|Macrophages|Macrophages activated|Monocytes|Dendritic cells|T cells|B cells|NK cells|Erythrocytes|Granulocytes|Adipocytes', ref$label.fine)]
unique(ref_fine$label.fine)
```

## Run SingleR

```{r}
# Perform SingleR on the main cell-type reference
ct_ann_main <- SingleR(test = raw_counts, # we could also use sce or raw_counts
                  ref = ref_main, 
                  labels = ref_main$label.main,
                  de.method = 'classic')

# Compare pruned and initial labels
unique(ct_ann_main$pruned.labels)
table(ct_ann_main$pruned.labels)
table(ct_ann_main$labels)
summary(is.na(ct_ann_main$pruned.labels))

# Perform SingleR on the fine cell-type reference
ct_ann_fine <- SingleR(test = raw_counts, # we could also use sce or raw_counts
                  ref = ref_fine, 
                  labels = ref_main$label.fine,
                  de.method = 'classic')

# Compare pruned and initial labels
unique(ct_ann_fine$pruned.labels)
table(ct_ann_fine$pruned.labels)
table(ct_ann_fine$labels)
summary(is.na(ct_ann_fine$pruned.labels))

```

## Inspect the quality of the SingleR predictions

```{r}
# Inspect quality of the predictions - main
plotScoreHeatmap(ct_ann_main)
plotDeltaDistribution(ct_ann_main,
                      ncol = 4,
                      dots.on.top = FALSE)

# Inspect quality of the predictions - main
plotScoreHeatmap(ct_ann_fine)
plotDeltaDistribution(ct_ann_fine,
                      ncol = 4,
                      dots.on.top = FALSE)
```

## Add SingleR predictions to Seurat object & visualise with umap

```{r}
# Add to seurat object
rownames(ct_ann_main)[1:5] # make sure you have cell IDs
# add the "main" labels to the seurat object
re_embed_filtered <- AddMetaData(re_embed_filtered,
                      ct_ann_main$labels,
                      col.name = 'SingleR_HCA_main')

# set the active identity
re_embed_filtered <- SetIdent(re_embed_filtered,
                   value = "SingleR_HCA_main")
# Visualise them on the UMAP
DimPlot(re_embed_filtered,
        group.by = "SingleR_HCA_main",
        label = TRUE,
        repel = TRUE,
        label.size = 3)

# add the "fine" labels to the seurat object
re_embed_filtered <- AddMetaData(re_embed_filtered,
                      ct_ann_fine$labels,
                      col.name = 'SingleR_HCA_fine')

# set the active identity
re_embed_filtered <- SetIdent(re_embed_filtered,
                   value = "SingleR_HCA_fine")
# Visualise them on the UMAP
DimPlot(re_embed_filtered,
        group.by = "SingleR_HCA_fine",
        label = TRUE,
        repel = TRUE,
        label.size = 3)
```

# 3. Annotate cell types: Tabula Muris Senis
- This is a method from Nick. I will start by downloading the `cellxgene` dataset and finding if I can use the SingleR method to annotate the cells. If not, I will work through his code.  

## Read in the reference datatset
```{r}
# Heart - A single-cell transcriptomic atlas characterizes ageing tissues in the mouse - 10x
# Assay: 10x 3' V2, Normal, 8,613 cells
# https://datasets.cellxgene.cziscience.com/13c8cee7-8487-473d-b942-39f9a9762d97.h5ad

ref_tabula_muris_senis <- zellkonverter::readH5AD(file = file.path(downloads, "13c8cee7-8487-473d-b942-39f9a9762d97.h5ad"))
class(ref_tabula_muris_senis) # SingleCellExperiment
```

## Convert ensembl IDs to mgi symbols to match the Seurat object

```{r}

# Extract your Ensembl IDs from the SCE
ensembl_ids <- rownames(ref_tabula_muris_senis)

# Connect to Ensembl biomart
mart <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

# Retrieve the mapping table
id_map <- getBM(
  attributes = c("ensembl_gene_id", "mgi_symbol"),
  filters = "ensembl_gene_id",
  values = ensembl_ids,
  mart = mart
)

# Make sure to preserve all rows (including genes lacking symbols)
id_map <- distinct(id_map)

# Add gene symbols to SCE rowData
rowData(ref_tabula_muris_senis)$gene_symbol <- 
  id_map$mgi_symbol[ match(ensembl_ids, id_map$ensembl_gene_id) ]

# Check uniqueness (important)
sum(duplicated(ref_tabula_muris_senis$gene_symbol))

# overwrite the ensembl rownames
rownames(ref_tabula_muris_senis) <- rowData(ref_tabula_muris_senis)$gene_symbol

# The cellxgene h5ad has raw counts in assay "X"
# First, explicitly name it as counts (good practice)
assay(ref_tabula_muris_senis, "counts") <- assay(ref_tabula_muris_senis, "X")

# Now compute proper log-normalized counts (this creates the "logcounts" assay)
ref_tabula_muris_senis <- logNormCounts(ref_tabula_muris_senis)

# Confirm it worked
assayNames(ref_tabula_muris_senis)
# "X"        "counts"   "logcounts"
```

## Run SingleR

```{r}

ct_ann_tabula_muris_senis <- SingleR(
  test = raw_counts,                  # your raw count matrix from Seurat
  ref = ref_tabula_muris_senis,
  labels = ref_tabula_muris_senis$cell_type,
  assay.type.test = "counts",         # raw counts in test
  assay.type.ref = "logcounts",
  de.method = "classic"
)
gc()

ct_ann_tabula_muris_senis_free <- SingleR(
  test = raw_counts,                  # your raw count matrix from Seurat
  ref = ref_tabula_muris_senis,
  labels = ref_tabula_muris_senis$free,   # or whichever column you prefer
  assay.type.test = "counts",         # raw counts in test
  assay.type.ref = "logcounts",
  de.method = "classic"
)
gc()
```

## Inspect the quality of the SingleR predictions

```{r}

# Inspect quality of the predictions
plotScoreHeatmap(ct_ann_tabula_muris_senis)
plotDeltaDistribution(ct_ann_tabula_muris_senis,
                      ncol = 4,
                      dots.on.top = FALSE)

```

## Add SingleR predictions to Seurat object & visualise with umap

```{r}
# Add to seurat object
rownames(ct_ann_tabula_muris_senis)[1:5] # make sure you have cell IDs
# add the "main" labels to the seurat object
re_embed_filtered <- AddMetaData(re_embed_filtered,
                      ct_ann_tabula_muris_senis$labels,
                      col.name = 'SingleR_tms')

# set the active identity
re_embed_filtered <- SetIdent(re_embed_filtered,
                   value = "SingleR_tms")
# Visualise them on the UMAP
DimPlot(re_embed_filtered,
        group.by = "SingleR_tms",
        label = TRUE,
        repel = TRUE,
        label.size = 3)

```



```{r}
# Annotate cell types: Tabula Muris Senis ---------------------------------

# I previously used a reference with comprehensive cell typing
# But it took 75 minutes to run
# I'll work with a less comprehensive reference for now, and perhaps go more fine-grained at the stromal level
# The time taken seems to scale with the number of cell types more than the number of cells in the reference

# Annotate with lower resolution:
# Using this reference: https://cellxgene.cziscience.com/collections/0b9d8a04-bb9d-44da-aa27-705bb65b54eb
# https://datasets.cellxgene.cziscience.com/c49b6300-3bda-4658-a0dc-be075537cb88.h5ad

reference_tbs_sce <- zellkonverter::readH5AD(file = file.path(downloads, "tabula_muris_sensis-mammary_gland_reference.h5ad"))
class(reference_tbs_sce) # sce

# Check memory usage
format(object.size(reference_tbs_sce), units = "GB") # Only 300 Mb

# Check the structure
dim(reference_tbs_sce)
# [1] 17943 12295

SingleCellExperiment::colData(reference_tbs_sce) %>% colnames()

SingleCellExperiment::colData(reference_tbs_sce) %>%
  as_tibble() %>%
  group_by(cell_type) %>%
  count() %>%
  arrange(desc(n))
# cell_type                                    n
# <fct>                                    <int>
# 1 T cell                                    3220
# 2 stromal cell                              2783
# 3 luminal epithelial cell of mammary gland  1903
# 4 B cell                                    1632
# 5 basal cell                                1587
# 6 endothelial cell                           651
# 7 macrophage                                 519
# Broader classes will be useful


# Extract reference data for SingleR
ref_matrix_tbs <- SummarizedExperiment::assay(reference_tbs_sce, "X")
class(ref_matrix_tbs)
dim(ref_matrix_tbs) # [1] 17943 12295

# Check gene name format
ref_matrix_tbs %>% rownames() %>% head()
# Ensembl

library(biomaRt)

# Convert to gene symbols
gene_mapping <- getBM(
  attributes = c("ensembl_gene_id", "mgi_symbol"),
  filters = "ensembl_gene_id",
  values = ref_matrix_tbs %>% rownames(),
  mart = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
)

gene_mapping %>% head()

# Any NA?
is.na(gene_mapping$mgi_symbol) %>% summary() # No
is.na(gene_mapping$ensembl_gene_id) %>% summary() # No

# Any empty?
summary(gene_mapping$mgi_symbol == "") # 3

# Any duplicates?
duplicated(gene_mapping$ensembl_gene_id) %>% summary()
# Mode   FALSE 
# logical   17943

# Check that genes are in the same order in reference data and biomart output:
table(rownames(ref_matrix_tbs) == gene_mapping$ensembl_gene_id)
# FALSE  TRUE 
# 17935     8  

# Get them in the same order
gene_mapping_ordered <- gene_mapping[match(rownames(ref_matrix_tbs), gene_mapping$ensembl_gene_id), ]

# Check
table(rownames(ref_matrix_tbs) == gene_mapping_ordered$ensembl_gene_id)
# TRUE 
# 17943 

# Remove empty gene symbols
gene_mapping_ordered <- gene_mapping_ordered[gene_mapping_ordered$mgi_symbol != "", ]
nrow(gene_mapping_ordered) # 17940 - correct

gene_mapping_ordered %>% head() # I just check one manually, and ENSMUSG00000020590 is indeed Snx13

# Subset reference matrix to genes with valid symbols
ref_matrix_tbs_subset <- ref_matrix_tbs[gene_mapping_ordered$ensembl_gene_id, ]

# Now rename genes
rownames(ref_matrix_tbs_subset) <- gene_mapping_ordered$mgi_symbol

# Verify
head(rownames(ref_matrix_tbs_subset))

rm(gene_mapping, ref_matrix_tbs)
gc()

query_matrix <- Seurat::GetAssayData(filtered, slot = "data") %>% as.matrix()
class(query_matrix)

# Predict cell types
system.time(
  pred_tbs <- SingleR::SingleR(
    test = query_matrix,
    ref = ref_matrix_tbs_subset,
    labels = reference_tbs_sce$cell_type,
    de.method = "wilcox"
  )
)
# This took around two minutes

pred_tbs

# Add to Seurat metadata; I'll include scores as well for now, and append the reference name
filtered <-
  add_metadata(object = filtered,
               metadata = pred_tbs %>%
                 as_tibble(rownames = "barcode") %>%
                 rename_with(~ ifelse(. == "barcode", ., paste(., "tbs", sep = ".")))
  )


# Convert NA labels to some other value, as NAs mess with plot colour assignments
filtered@meta.data <-
  filtered@meta.data %>%
  mutate(pruned.labels.tbs = case_when(is.na(pruned.labels.tbs) ~ "pruned - NA",
                                       .default = pruned.labels.tbs))


# Clean up
rm(gene_mapping_ordered, pred_tbs, query_matrix, ref_matrix_tbs_subset, reference_tbs_sce)
gc()
```



