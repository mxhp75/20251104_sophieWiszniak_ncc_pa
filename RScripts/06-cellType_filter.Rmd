---
title: "06-cellType_filter"
author: "Melanie Smith"
date: "2026-01-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Clean-up environment

```{r}
rm(list = ls(all.names = TRUE)) # will clear all objects includuing hidden objects
gc() # free up memory and report the memory usage
options(max.print = .Machine$integer.max,
        scipen = 999,
        stringsAsFactors = FALSE,
        dplyr.summarise.inform = FALSE) # Print everything without truncation, avoid scientific notation, keep strings as characters, silence dplyr’s “grouped output” informational messages
set.seed(42) # set seed for reproducibility
```

# Load Libraries

```{r}
# Core tidyverse
library(tidyverse)
library(tibble)
library(dplyr)
library(tidyr)

# Single Cell
library(Seurat) # Seurat (relies on dplyr/tidyr, so load after tidyverse)

library(SingleCellExperiment)
library(biomaRt)
library(scuttle)

# additional plotting functions
library(patchwork)
library(pheatmap)
```

# User defined functions

```{r}
# Helper function (put this at the top of your script)
save_if <- function(plot_object, filename, width, height, ...) {
  if (save_plots) {
    ggsave(plot = plot_object,
           filename = filename,
           width = width,
           height = height,
           dpi = 300)
  }
}
# change to TRUE to save plots
save_plots <- TRUE

# quick function (following from Nick's) to plot the QC metrics
my_plot_function <- function(object, grouping_variable, variables_to_plot) {
  
  group_var_sym <- sym(grouping_variable)
  
  object[[]] %>%
    as_tibble(rownames = "barcode") %>%
    dplyr::select(barcode, !!group_var_sym, all_of(variables_to_plot)) %>%
    pivot_longer(
      cols = -c(barcode, !!group_var_sym),
      names_to = "metric",
      values_to = "values"
    ) %>%
    ggplot(aes(x = !!group_var_sym, y = values)) +
    
    # Right half: density + median line
    ggdist::stat_halfeye(
      side = "right",
      fill = "dodgerblue",
      alpha = 0.5,
      .width = 0.5,           # median line
      justification = -0.2,
      scale = 0.9,
      linewidth = 0.4,
      color = "black"
    ) +
    
    # Left half: dots
    ggdist::stat_dots(
      side = "left",
      alpha = 0.3,
      justification = 1.25,
      quantiles = NULL,       # prevents binwidth error
      dotsize = 0.7
    ) +

    facet_wrap(~ metric, scales = "free") +
    theme_bw() +
    theme(
      panel.grid.major.x = element_blank(),
      axis.text.x = element_text(angle = 90, hjust = 0.5)
    )
}
```

# Set project directories and file paths

```{r}
project_name <- "20251104_sophieWiszniak_ncc_pa"

base_repo_dir <- "/home/melanie-smith/workDir/sophieWiszniak"
project_repo_dir <- file.path(base_repo_dir, project_name)
data_base_dir <- file.path(project_repo_dir, "rawData")
out_dir <- file.path(project_repo_dir, "outDir")
downloads <- file.path(project_repo_dir, "downloads")

new_out_dir <- file.path(out_dir, "05-secondary_QC")

```

# Load required objects
- This object has been filtered for doublets, >10% MT genes and low quality clusters have been removed

```{r}
re_embed_no_low.qual <- readRDS(file = file.path(new_out_dir, "re_embed_filtered_no_multi_fail.rds"))
# Save the existing seurat clusters before we filter and re-embed
re_embed_no_low.qual$seurat_clusters_mt_dbl_quality <- re_embed_no_low.qual$seurat_clusters
```

## Quick UMAP for orientation

```{r}
DimPlot(re_embed_no_low.qual,
        reduction = "umap",
        group.by = "seurat_clusters",
        label = TRUE,
        label.size = 6
        )
```

# Remove un-interesting cell types (RBCs, platelets, macrophages)

```{r}
# Check starting number of cells
cat("Starting number of cells:", ncol(re_embed_no_low.qual), "\n")
cat("Red Blood Cells:", sum(re_embed_no_low.qual$seurat_clusters %in% c(13, 20)), "\n")
cat("Macrophages:", sum(re_embed_no_low.qual$seurat_clusters == 21), "\n")
cat("Platelets:", sum(re_embed_no_low.qual$seurat_clusters == 23), "\n")

cat("Total uninteresting cells to remove:", sum(re_embed_no_low.qual$seurat_clusters %in% c(13, 20, 21, 23)), "\n\n")

# Subset to remove low-quality clusters
re_embed_interesting_cells <- subset(re_embed_no_low.qual, 
                          subset = seurat_clusters %in% c(13, 20, 21, 23), 
                          invert = TRUE)

cat("Number of interesting cells:", ncol(re_embed_interesting_cells), "\n\n")

```

## Quick UMAP for orientation post cluster removal (no re-embedding)

```{r}
DimPlot(re_embed_interesting_cells,
        reduction = "umap",
        group.by = "seurat_clusters",
        label = TRUE,
        label.size = 6
        )
```

# Hb gene expression by cluster

```{r}
# Hb content feature plot
FeaturePlot(re_embed_interesting_cells,
            features = "percent.hb") &
  scale_colour_gradientn(
    colours = rev(
      RColorBrewer::brewer.pal(
        n = 11, 
        name = "Spectral")
      )
    )

# extract the value of the 3rd quartile
quartile_3rd <- summary(re_embed_interesting_cells@meta.data$percent.hb)[[5]]

# per cluster > 3rd quartile breakdown
above_3rd <- re_embed_interesting_cells@meta.data %>%
  group_by(seurat_clusters) %>%
  summarise(
    n_cells = n(),
    n_above_3rd = sum(percent.hb > quartile_3rd, na.rm = TRUE),
    pct_above_3rd = round(100 * n_above_3rd / n_cells, 2)
  ) %>%
  arrange(desc(pct_above_3rd))

# how many cells with >10% hb
re_embed_interesting_cells@meta.data %>%
  group_by(seurat_clusters) %>%
  summarise(
    n_cells = n(),
    n_above_10 = sum(percent.hb > 10.0, na.rm = TRUE),
    pct_above_10 = round(100 * n_above_10 / n_cells, 2)
  ) %>%
  arrange(desc(pct_above_10))

# MAD
n_mad_upper <- 5
# Compute per-cluster upper hb threshold and add logical flag
re_embed_interesting_cells@meta.data <- re_embed_interesting_cells@meta.data %>%
  tibble::rownames_to_column("cell_id") %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::mutate(
    # Compute threshold per cluster (on log scale for skewness)
    upper_threshold_hb = median(log10_percent.hb) + (mad(log10_percent.hb) * n_mad_upper),
    # Flag cells below the threshold (TRUE = low quality)
    hb_filter = log10_percent.hb > upper_threshold_hb
  ) %>%
  dplyr::ungroup() %>%
  tibble::column_to_rownames("cell_id")

# Count flagged cells per cluster
table(re_embed_interesting_cells@meta.data$seurat_clusters, re_embed_interesting_cells@meta.data$hb_filter)

# Per-cluster thresholds
threshold_pct_hb <- re_embed_interesting_cells@meta.data %>%
  group_by(seurat_clusters) %>%
  summarize(unique_threshold_pct_hb = unique(upper_threshold_hb)) %>%
  dplyr::mutate(threshold_pct_hb = unique_threshold_pct_hb)

# Step 2: Create VlnPlot (on linear scale, which is most common for nFeature)
p <- VlnPlot(re_embed_interesting_cells,
             features = "log10_percent.hb",
             group.by = "seurat_clusters",
             pt.size = 0.5,
             cols = scales::hue_pal()(length(unique(re_embed_interesting_cells$seurat_clusters)))) +
  labs(title = "Per Cluster Upper % hb QC Thresholds",
       y = "log10_percent.hb",
       subtitle = paste("Threshold = median(log10_percent.hb) +", n_mad_upper, "× MAD"),
       caption = "Filtered: <10% MT, singlets only, interesting cells (old clusters)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# manually set the y-limit
p <- p + ylim(0, max(re_embed_interesting_cells@meta.data$log10_percent.hb, na.rm = TRUE) * 1.3)

# Short cluster level red dashed segment and threshold value centered on each violin
p + geom_segment(
  data = threshold_pct_hb,
  aes(
    x = as.numeric(seurat_clusters) - 0.35,     # start a bit left of center
    xend = as.numeric(seurat_clusters) + 0.35,  # end a bit right of center
    y = threshold_pct_hb,
    yend = threshold_pct_hb
  ),
  color = "red",
  linetype = "dashed",
  linewidth = 0.9,
  inherit.aes = FALSE
) +
  # White box label with slight padding and border
  geom_label(
    data = threshold_pct_hb,
    aes(
      x = as.numeric(seurat_clusters),
      y = threshold_pct_hb * 1.5,
      label = round(threshold_pct_hb, 3)
    ),
    color = "black",                # text color
    fill = "white",                 # background color (white box)
    label.size = 0.35,              # thickness of the border (set to 0 for no border)
    size = 3.2,                     # text size
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  NoLegend()

  
```

# Filter based in hb% + 5 MADs

```{r}
# How many cells fail the hb filter?
table(re_embed_interesting_cells@meta.data$hb_filter)

# Subset to keep only cells that fail the hb filter filters (i.e. keep only hb_filter == TRUE)
re_embed_interesting_cells_hb <- subset(re_embed_interesting_cells,
                            subset = hb_filter != TRUE)

# remake the violins after filtering
# Step 2: Create VlnPlot (on linear scale, which is most common for nFeature)
p2 <- VlnPlot(re_embed_interesting_cells_hb,
             features = "log10_percent.hb",
             group.by = "seurat_clusters",
             pt.size = 0.5,
             cols = scales::hue_pal()(length(unique(re_embed_interesting_cells_hb$seurat_clusters)))) +
  labs(title = "Per Cluster Upper % hb QC Thresholds",
       y = "log10_percent.hb",
       subtitle = paste("Threshold = median(log10_percent.hb) +", n_mad_upper, "× MAD"),
       caption = "Filtered: <10% MT, singlets only, interesting cells (old clusters)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# manually set the y-limit
p2 <- p2 + ylim(0, max(re_embed_interesting_cells_hb@meta.data$log10_percent.hb, na.rm = TRUE) * 1.3)

# Short cluster level red dashed segment and threshold value centered on each violin
p2 + geom_segment(
  data = threshold_pct_hb,
  aes(
    x = as.numeric(seurat_clusters) - 0.35,     # start a bit left of center
    xend = as.numeric(seurat_clusters) + 0.35,  # end a bit right of center
    y = threshold_pct_hb,
    yend = threshold_pct_hb
  ),
  color = "red",
  linetype = "dashed",
  linewidth = 0.9,
  inherit.aes = FALSE
) +
  # White box label with slight padding and border
  geom_label(
    data = threshold_pct_hb,
    aes(
      x = as.numeric(seurat_clusters),
      y = threshold_pct_hb * 1.5,
      label = round(threshold_pct_hb, 3)
    ),
    color = "black",                # text color
    fill = "white",                 # background color (white box)
    label.size = 0.35,              # thickness of the border (set to 0 for no border)
    size = 3.2,                     # text size
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  NoLegend()
```

# Re-embed: Normalise, find variable features, scale, PCA, UMAP, cluster

```{r}
n_dims = 30
clustering_resolution_0.8 = 0.8
# Re-computation of graph-based clustering and UMAP on the cleaned dataset
re_embed_interesting_cells_0.8 <- FindVariableFeatures(re_embed_interesting_cells_hb,
                                        selection.method = "vst", 
                                        nfeatures = 3000,
                                        verbose = FALSE) %>%
  ScaleData(features = rownames(re_embed_interesting_cells_hb),
            verbose = FALSE) %>%
  RunPCA(verbose = FALSE) %>% # Defaults to features = VariableFeatures()), but better not to specify as these are not yet stored in that object
  FindNeighbors(dims = 1:n_dims,
                verbose = FALSE) %>%
  FindClusters(resolution = clustering_resolution_0.8,
               verbose = FALSE) %>%
  RunUMAP(dims = 1:n_dims,
          verbose = FALSE)

# plot the umap with old cluster numbers and colours
umap_oldCluster <- DimPlot(re_embed_interesting_cells_0.8,
        reduction = "umap",
        group.by = "seurat_clusters_mt_dbl_quality",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (old clusters)",
    caption = "Filtered: Interesting cells (old clusters)"
  ) +
  NoLegend()

save_if(umap_oldCluster,
        filename = file.path(out_dir, "06-cluster_marker_genes", "06-umap.re_embed_interesting_cells.old_clusters.png"),
        width = 8,
        height = 8)

# plot the umap with new cluster numbers and colours
umap_newCluster <- DimPlot(re_embed_interesting_cells_0.8,
        reduction = "umap",
        group.by = "seurat_clusters",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (new clusters)",
    caption = "Filtered: Interesting cells (new clusters)"
  ) +
  NoLegend()
save_if(umap_newCluster,
           filename = file.path(out_dir, "06-cluster_marker_genes", "06-umap.re_embed_interesting_cells.new_clusters.png"),
           width = 8,
           height = 8)

# plot the umap with new cluster numbers and colours
umap_sophieCluster <- DimPlot(re_embed_interesting_cells_0.8,
        reduction = "umap",
        group.by = "sophie_celltype_clean",
        label = TRUE,
        label.size = 4
        ) +
  labs(
    title = "UMAP - new embedding (Sophie anno)",
    caption = "Filtered: Interesting cells (Sophie Anno)"
  )
save_if(umap_sophieCluster,
           filename = file.path(out_dir, "06-cluster_marker_genes", "06-umap.re_embed_interesting_cells.sophie_anno.png"),
           width = 8,
           height = 8)

# let's save here and reload in a new session
write_rds(x = re_embed_interesting_cells_0.8,
          file = file.path(out_dir, "06-cluster_marker_genes", "re_embed_interesting_cells_0.8.rds"))

```

```{r}
n_dims = 30
clustering_resolution = 0.6
# Re-computation of graph-based clustering and UMAP on the cleaned dataset
re_embed_interesting_cells_0.6 <- FindVariableFeatures(re_embed_interesting_cells_hb,
                                                      selection.method = "vst", 
                                                      nfeatures = 3000,
                                                      verbose = FALSE) %>%
  ScaleData(features = rownames(re_embed_interesting_cells_hb),
            verbose = FALSE) %>%
  RunPCA(verbose = FALSE) %>% # Defaults to features = VariableFeatures()), but better not to specify as these are not yet stored in that object
  FindNeighbors(dims = 1:n_dims,
                verbose = FALSE) %>%
  FindClusters(resolution = clustering_resolution,
               verbose = FALSE) %>%
  RunUMAP(dims = 1:n_dims,
          verbose = FALSE)

DimPlot(re_embed_interesting_cells_0.6,
        reduction = "umap",
        group.by = "seurat_clusters",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (new clusters)",
    caption = "Filtered: Interesting cells (new clusters)"
  ) +
  NoLegend()

DimPlot(re_embed_interesting_cells_0.6,
        reduction = "umap",
        group.by = "sophie_celltype_clean",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (Sophie cell type)",
    caption = "Filtered: Interesting cells (new clusters)"
  ) +
  NoLegend()

# Remap the cell types to the new seurat clusters
re_embed_interesting_cells_0.6@meta.data <- re_embed_interesting_cells_0.6@meta.data %>%
  dplyr::mutate(
    new_celltypes = case_when(
      seurat_clusters %in% c(4, 9, 12) ~ "Myocardium",
      seurat_clusters %in% c(1, 13) ~ "VSMC",
      seurat_clusters %in% c(7, 14) ~ "Epicardium",
      seurat_clusters %in% c(0, 2, 3, 5, 8, 10) ~ "Mesenchyme",
      seurat_clusters %in% c(6, 11, 15, 16) ~ "Endocardium",
      TRUE ~ "Other/Unknown"   # safety catch for any missing clusters
      )
    )

# Verify the mapping looks correct
table(re_embed_interesting_cells_0.6@meta.data$seurat_clusters, 
      re_embed_interesting_cells_0.6@meta.data$new_celltypes, 
      useNA = "ifany")

# Or just a simple count
table(re_embed_interesting_cells_0.6$new_celltypes)

# Visual sanity check
umap_newSophieCellType <- DimPlot(re_embed_interesting_cells_0.6,
        group.by = "new_celltypes",
        label = TRUE,
        repel = TRUE,
        label.size = 6) + 
  scale_color_manual(values = c("Myocardium" = "#E41A1C", "VSMC" = "#377EB8", 
                                "Epicardium" = "#4DAF4A", "Mesenchyme" = "#984EA3", 
                                "Endocardium" = "#FF7F00", "Other/Unknown" = "grey70"))
save_if(umap_newSophieCellType,
           filename = file.path(out_dir, "06-cluster_marker_genes", "06-umap.re_embed_interesting_cells.umap_newSophieCellType.png"),
           width = 8,
           height = 8)

# let's save here and reload in a new session
write_rds(x = re_embed_interesting_cells_0.6,
          file = file.path(out_dir, "06-cluster_marker_genes", "final_interesting_cells_0.6.rds"))
```

# Stacked barchart

```{r}
df <- re_embed_interesting_cells_0.6@meta.data %>%
  dplyr::select(orig.ident, new_celltypes, seurat_clusters) %>%
  dplyr::mutate(cluster_celltype = paste(seurat_clusters, new_celltypes, sep = "_"))

# quick check
table(re_embed_interesting_cells_0.6@meta.data$orig.ident,
      re_embed_interesting_cells_0.6@meta.data$new_celltypes,
      useNA = "ifany")

table(df$orig.ident,
      df$cluster_celltype,
      useNA = "ifany")

# control the stacking order (match the dot plot
df$new_celltypes <- factor(
  df$new_celltypes,
  levels = c("Mesenchyme", "Myocardium", "Endocardium", "Epicardium", "VSMC"))

df$cluster_celltype <- factor(
  df$cluster_celltype,
  levels = c("0_Mesenchyme", "2_Mesenchyme", "3_Mesenchyme", "5_Mesenchyme", "8_Mesenchyme", "10_Mesenchyme",
             "4_Myocardium", "9_Myocardium", "12_Myocardium",
             "6_Endocardium", "11_Endocardium", "15_Endocardium", "16_Endocardium",
             "7_Epicardium","14_Epicardium",
             "1_VSMC", "13_VSMC"))

ggplot(df, aes(x = orig.ident,
               fill = new_celltypes)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    x = "Sample",
    y = "Proportion of cells",
    fill = "Cell type",
    title = "Relative cell type composition per sample"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

ggplot(df, aes(x = orig.ident,
               fill = cluster_celltype)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    x = "Sample",
    y = "Proportion of cells",
    fill = "Cell type",
    title = "Relative cell type composition per sample"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

celltype_cols <- c(
  "Myocardium" = "#E41A1C",
  "VSMC" = "#377EB8", 
  "Epicardium" = "#4DAF4A",
  "Mesenchyme" = "#984EA3", 
  "Endocardium" = "#FF7F00"
)

ggplot(df, aes(x = orig.ident, fill = new_celltypes)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = celltype_cols) +
  scale_y_continuous(labels = scales::percent) +
  theme_bw()

cluster_celltype_cols <- c(
  "0_Mesenchyme" = "midnightblue",
  "2_Mesenchyme" = "darkolivegreen1",
  "3_Mesenchyme" = "royalblue3",
  "5_Mesenchyme" = "royalblue4",
  "8_Mesenchyme" = "turquoise3",
  "10_Mesenchyme" = "chartreuse1",
  "4_Myocardium" = "darkorange",
  "9_Myocardium" = "royalblue1",
  "12_Myocardium" = "darkgoldenrod1",
  "6_Endocardium" = "darkblue",
  "11_Endocardium" = "firebrick3",
  "15_Endocardium" = "aquamarine",
  "16_Endocardium" = "lightcoral",
  "7_Epicardium" = "cyan3",
  "14_Epicardium" = "mediumspringgreen",
  "1_VSMC" = "springgreen",
  "13_VSMC" = "red"
  )

ggplot(df, aes(x = orig.ident, fill = new_celltypes)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = celltype_cols) +
  scale_y_continuous(labels = scales::percent) +
  theme_bw()

ggplot(df, aes(x = orig.ident, fill = cluster_celltype)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = cluster_celltype_cols) +
  scale_y_continuous(labels = scales::percent) +
  theme_bw()
```

```{r}
# plot the umap with new cluster numbers and colours
umap_newCluster_time <- DimPlot(re_embed_interesting_cells_0.6,
        reduction = "umap",
        group.by = "seurat_clusters",
        split.by = "orig.ident",
        label = TRUE,
        label.size = 6
        ) +
  labs(
    title = "UMAP - new embedding (new clusters)",
    caption = "Filtered: Interesting cells (new clusters)"
  ) +
  NoLegend()

FeaturePlot(re_embed_interesting_cells_0.6,
            features = c("G2M.Score", "S.Score"),
            reduction = "umap",
            label = TRUE,
            label.size = 6) &
  scale_colour_gradientn(
    colours = rev(RColorBrewer::brewer.pal(11, "Spectral")),
    name = "Expression"
    )

```


